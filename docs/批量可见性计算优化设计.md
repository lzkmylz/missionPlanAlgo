# 批量可见性计算优化设计文档

**日期**: 2026-02-27
**状态**: 设计完成，准备实施

---

## 1. 背景与目标

### 当前问题

| 指标 | 数值 | 问题 |
|------|------|------|
| 计算时间 | 420秒 (7分钟) | 用户无法接受 |
| JNI调用次数 | 390次 | 频繁跨语言调用 |
| Java对象创建 | 26,000+个 | 轨道/传播器重复创建 |
| 坐标转换 | 84,000+次 | Python-Java数据传递开销大 |

对比Python简化模型（0.79秒），Java后端慢 **529倍**。

### 设计目标

**主要目标**: 在保持Orekit精度的前提下，将计算时间从420秒减少到 **15-30秒**（加速14-28倍）。

**具体指标**:
- JNI调用次数: 从390次减少到 **2次**
- Java对象创建: 从26,000个减少到 **15个**（轨道对象复用）
- 坐标转换: 从84,000次减少到 **0次**（全部在Java端完成）

---

## 2. 架构设计

### 总体架构

```
Python端                                 Java端
─────────────────────────────────────────────────────────────
场景加载 ──────▶ 参数序列化 ──────▶ JNI调用(单次)
                                                 │
结果解析 ◀────── 结果反序列化 ◀────── 批量计算
                                                
核心优化点:
1. 单次JNI调用完成全部计算
2. Java端对象池复用(15个轨道对象)
3. 并行传播(每颗卫星独立线程)
4. 零坐标转换(全部在Java端)
```

### 关键设计决策

| 决策 | 选择 | 理由 |
|------|------|------|
| 传播模式 | MasterMode + EventDetector | 高效的事件驱动传播 |
| 并行策略 | Java端并行 | 避免Python GIL限制 |
| 对象管理 | 对象池复用 | 减少GC压力 |
| 错误处理 | 自动回退到逐对计算 | 确保系统可用性 |

---

## 3. 核心类设计

### 3.1 Python端

**BatchVisibilityCalculator**
```python
class BatchVisibilityCalculator:
    def compute_all_windows(
        self,
        satellites: List[Satellite],
        targets: List[Target],
        ground_stations: List[GroundStation],
        start_time: datetime,
        end_time: datetime,
    ) -> BatchVisibilityResult:
        # 1. 序列化参数
        # 2. 单次JNI调用Java
        # 3. 反序列化结果
        # 4. 错误时回退到逐对计算
```

**配置**
```python
@dataclass
class BatchComputationConfig:
    coarse_step_seconds: float = 300.0  # 粗扫描步长
    fine_step_seconds: float = 60.0     # 精化步长
    min_elevation_degrees: float = 0.0
    use_parallel_propagation: bool = True
    fallback_on_error: bool = True
```

### 3.2 Java端

**BatchVisibilityCalculator**
```java
public class BatchVisibilityCalculator {
    public BatchResult computeAllWindows(
        List<SatelliteParameters> satellites,
        List<GroundPoint> targets,
        List<GroundPoint> groundStations,
        AbsoluteDate startTime,
        AbsoluteDate endTime,
        ComputationConfig config
    ) {
        // 1. 创建轨道传播器池（复用）
        // 2. 设置仰角检测器（所有对）
        // 3. 批量传播（并行/串行）
        // 4. 精化窗口边界
        // 5. 返回结果
    }
}
```

**Python调用入口**
```java
public class PythonBridge {
    public static Map<String, Object> computeVisibilityBatch(...) {
        // Python通过JPype调用此静态方法
        // 返回结果转换为Python友好的Map格式
    }
}
```

---

## 4. 性能优化策略

### 优化效果对比

| 优化点 | 当前 | 优化后 | 效果 |
|--------|------|--------|------|
| JNI调用 | 390次 | 2次 | 减少195倍 |
| Java对象 | 26,000个 | 15个 | 减少1734倍 |
| 坐标转换 | 84,000次 | 0次 | 完全消除 |
| 传播器创建 | 195个 | 15个 | 减少13倍 |

### 预估性能

| 场景 | 当前时间 | 预估时间 | 加速比 |
|------|----------|----------|--------|
| 小规模 (2卫星2目标) | ~30s | ~6s | 5x |
| 中规模 (5卫星4目标) | ~150s | ~15s | 10x |
| 大规模 (15卫星6目标) | 420s | 15-30s | 14-28x |

---

## 5. 文件清单与实施计划

### 5.1 新建文件

| 文件 | 说明 |
|------|------|
| `core/orbit/visibility/batch_calculator.py` | Python端批量计算器 |
| `java/src/orekit/visibility/BatchVisibilityCalculator.java` | Java端核心计算器 |
| `java/src/orekit/visibility/WindowTracker.java` | 线程安全窗口追踪器 |
| `java/src/orekit/visibility/ElevationHandler.java` | 仰角事件处理器 |
| `java/src/orekit/visibility/PythonBridge.java` | Python调用入口 |
| `java/src/orekit/visibility/*Params.java` | 数据类(4个) |
| `tests/unit/core/orbit/test_batch_visibility.py` | 单元测试 |
| `scripts/benchmark_batch_visibility.py` | 性能基准测试 |

### 5.2 修改文件

| 文件 | 修改内容 |
|------|----------|
| `orekit_java_bridge.py` | 添加`compute_visibility_batch`方法 |
| `orekit_visibility.py` | 添加批量计算入口 |
| `compute_visibility.py` | 使用新API |

### 5.3 实施步骤

**Phase 1: Java端实现 (2-3天)**
1. 创建Java数据类
2. 实现WindowTracker
3. 实现BatchVisibilityCalculator
4. 实现PythonBridge
5. 编译测试

**Phase 2: Python端集成 (1-2天)**
1. 更新OrekitJavaBridge
2. 实现BatchVisibilityCalculator
3. 添加序列化/反序列化

**Phase 3: 测试验证 (2-3天)**
1. 编写单元测试
2. 正确性验证
3. 性能基准测试
4. 参数调优

**Phase 4: 部署 (1天)**
1. 更新文档
2. 集成到compute_visibility.py

---

## 6. 使用示例

```python
from core.models import Mission
from core.orbit.visibility.batch_calculator import BatchVisibilityCalculator

mission = Mission.load("scenarios/point_group_scenario.json")

calc = BatchVisibilityCalculator()
result = calc.compute_all_windows(
    satellites=mission.satellites,
    targets=mission.targets,
    ground_stations=mission.ground_stations,
    start_time=mission.start_time,
    end_time=mission.end_time,
)

print(f"总窗口数: {result.total_window_count}")
print(f"Java计算时间: {result.computation_stats.java_computation_time_ms}ms")

windows = result.get_windows_for_satellite_target("WALKER-01-01", "TARGET-001")
```

---

## 7. 风险与缓解

| 风险 | 可能性 | 影响 | 缓解措施 |
|------|--------|------|----------|
| Java编译失败 | 低 | 高 | 提前验证Orekit版本兼容性 |
| 结果精度下降 | 中 | 高 | 与逐对计算对比验证 |
| 内存溢出 | 中 | 中 | 限制批次大小，分批处理 |
| JNI不稳定 | 低 | 高 | 实现重试机制和回退方案 |

---

## 8. 结论

通过批量计算优化，预计可以将可见性计算时间从**420秒减少到15-30秒**，同时保持Orekit的高精度。

**关键成功因素**:
1. Java端对象复用（15个轨道对象）
2. 单次JNI调用（消除跨语言开销）
3. 并行传播（利用多核CPU）
4. 健壮的错误处理（自动回退）

**准备开始实施**。
