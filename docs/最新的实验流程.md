# 卫星星座任务规划算法实验流程文档

本文档详细描述卫星星座任务规划算法研究平台的核心实验流程，涵盖从场景配置到批量对比实验的完整工作流。

---

## 目录

1. [场景配置流程](#1-场景配置流程)
2. [可见性计算流程](#2-可见性计算流程)
3. [算法执行流程](#3-算法执行流程)
4. [结果验证流程](#4-结果验证流程)
5. [性能评估流程](#5-性能评估流程)
6. [批量实验流程](#6-批量实验流程)
7. [Docker容器化流程](#7-docker容器化流程)

---

## 1. 场景配置流程

### 概述

使用场景配置工具套件（CLI）定义实验环境，包括卫星星座、载荷、目标、地面站等全部实体及其参数配置。

### 1.1 安装与初始化

```bash
# 安装项目依赖
pip install -r requirements.txt
pip install -e .

# 验证CLI工具安装
sat-cli --version
```

### 1.2 实体库管理

实体库存储可复用的卫星模板、目标、地面站配置，位于 `data/entity_lib/`。

#### 查看实体库

```bash
# 列出所有卫星模板
sat-cli lib list --type satellite

# 查看模板详情
sat-cli lib show satellite optical_1

# 列出所有目标
sat-cli lib list --type target
```

#### 添加自定义实体

```bash
# 添加卫星模板（交互式向导）
sat-cli lib add-satellite --id optical_custom

# 添加点目标
sat-cli lib add-target \
    --id nanjing \
    --name "南京目标" \
    --lon 118.8 \
    --lat 32.1 \
    --priority 7

# 删除实体
sat-cli lib remove --type target --id old_target
```

### 1.3 场景初始化

#### 创建空场景

```bash
# 初始化空场景（生成模板框架）
sat-cli init scenarios/my_scenario.json

# 带元数据的初始化
sat-cli init scenarios/my_scenario.json --with-metadata
```

生成的场景文件结构：

```json
{
  "name": "my_scenario",
  "description": "",
  "start_time": "2024-01-01T00:00:00Z",
  "end_time": "2024-01-02T00:00:00Z",
  "metadata": {
    "coordinate_system": "WGS84",
    "time_system": "UTC",
    "time_format": "ISO8601",
    "created_at": "2024-01-01T00:00:00Z",
    "version": "1.0"
  },
  "satellites": [],
  "targets": [],
  "ground_stations": []
}
```

#### 克隆现有场景

```bash
# 基于现有场景创建变体
sat-cli clone scenarios/base.json --output scenarios/variant.json
```

### 1.4 Walker星座生成

Walker星座标准配置由四个参数决定：**i:T/P/F**（倾角、总卫星数、轨道面数、相位因子）。

#### 基础Walker生成

```bash
# Walker Delta 星座（默认相位因子 F=1）
sat-cli walker scenarios/my_scenario.json \
    --template optical_1 \
    --planes 2 \
    --sats-per-plane 3 \
    --raan-start 180.0 \
    --raan-spread 180.0 \
    --f-factor 1 \
    --prefix "WALKER"

# Walker Star 极轨道星座（F=0）
sat-cli walker scenarios/my_scenario.json \
    --template optical_1 \
    --planes 3 \
    --sats-per-plane 4 \
    --inclination 90.0 \
    --f-factor 0 \
    --prefix "POLAR"
```

#### 使用预设配置

```bash
# 使用预设快速生成常见星座
sat-cli walker scenarios/my_scenario.json \
    --preset delta_24_3_1 \
    --template optical_1

# 可用预设:
# --preset delta_24_3_1   # GPS-like: 55°倾角, 24颗, 3面, F=1
# --preset delta_66_6_1   # 铱星升级版: 55°倾角, 66颗, 6面, F=1
# --preset star_24_3_0    # 极轨道: 90°倾角, 24颗, 3面, F=0
# --preset star_48_6_0    # 极轨道密集: 90°倾角, 48颗, 6面, F=0
```

### 1.5 添加实体到场景

```bash
# 添加卫星（试运行查看效果）
sat-cli add-to-scenario scenarios/my_scenario.json \
    --entity-type satellite \
    --template optical_1 \
    --id OPT-01 \
    --raan 180.0 \
    --dry-run

# 确认后应用
sat-cli add-to-scenario scenarios/my_scenario.json \
    --entity-type satellite \
    --template optical_1 \
    --id OPT-01 \
    --raan 180.0

# 批量添加目标
sat-cli add-to-scenario scenarios/my_scenario.json \
    --entity-type target \
    --from-file data/china_cities.json
```

### 1.6 场景校验

```bash
# 基础校验
sat-cli validate scenarios/my_scenario.json

# 详细报告（rich彩色表格）
sat-cli validate scenarios/my_scenario.json --verbose

# 可行性检查（可见性窗口分析）
sat-cli check-feasibility scenarios/my_scenario.json
```

### 1.7 参数扫描（批量场景生成）

```bash
# 单参数扫描
sat-cli sweep \
    --base-scenario scenarios/base.json \
    --param satellites[0].capabilities.storage_capacity \
    --range 500:2000:100 \
    --output-dir scenarios/sweep_storage/

# 多参数组合扫描
sat-cli sweep \
    --base-scenario scenarios/base.json \
    --param satellites[0].capabilities.storage_capacity --range 500:2000:100 \
    --param satellites[0].capabilities.power_capacity --range 2000:4000:200 \
    --output-dir scenarios/sweep_combined/
```

输出结构：
```
scenarios/sweep_storage/
├── base_storage_500.json
├── base_storage_600.json
├── base_storage_700.json
└── ...
```

### 1.8 场景差异比对

```bash
# 比对两个场景的差异
sat-cli diff scenarios/base.json scenarios/variant.json
```

### 步骤分解

| 步骤 | 操作 | 输入 | 输出 |
|-----|------|------|------|
| 1.1 | 初始化实体库 | 默认模板 | `data/entity_lib/` 目录结构 |
| 1.2 | 添加自定义模板 | 卫星/目标参数 | 实体库JSON文件 |
| 1.3 | 初始化场景 | 场景名称 | 空场景JSON框架 |
| 1.4 | 生成Walker星座 | 模板ID、T/P/F参数 | 多颗卫星配置 |
| 1.5 | 添加目标 | 目标文件或参数 | 场景中的目标列表 |
| 1.6 | 校验场景 | 场景JSON | 校验报告 |
| 1.7 | 参数扫描（可选） | 基础场景、参数范围 | 场景矩阵 |

---

## 2. 可见性计算流程

### 概述

预先计算所有卫星-目标的访问时间窗口，为调度算法执行提供基础数据。支持窗口缓存机制避免重复计算。

### 步骤分解

| 步骤 | 操作 | 输入 | 输出 |
|-----|------|------|------|
| 2.1 | 选择轨道传播器 | 精度要求 | 传播器实例 |
| 2.2 | 预计算窗口缓存 | 卫星、目标、时间范围 | `VisibilityWindowCache` |
| 2.3 | 计算访问窗口 | 卫星位置、目标位置 | 可见时间窗口列表 |
| 2.4 | 过滤地影期 | 太阳位置、卫星位置 | 有效访问窗口 |
| 2.5 | 应用仰角约束 | 最小仰角配置 | 过滤后的窗口 |

### 2.1 轨道传播器选择

**精度vs效率权衡**：

| 传播器 | 精度 | 速度 | 适用场景 |
|-------|------|------|---------|
| SGP4 | 中 | 最快 | 低轨短期预测、快速验证 |
| Orekit | 高 | 中等 | 开源免费，精度足够大多数实验 |
| STK HPOP | 最高 | 慢 | 需要高精度（考虑大气阻力、太阳光压） |

### 2.2 窗口缓存机制

在批量实验中，窗口缓存可显著提升性能：

```python
from experiments.runner import ExperimentRunner, ExperimentConfig
from core.orbit.visibility.orekit_visibility import OrekitVisibilityCalculator

# 创建实验运行器
config = ExperimentConfig(repetitions=10)
runner = ExperimentRunner(mission, algorithms, config)

# 预计算所有可见性窗口（只需执行一次）
calculator = OrekitVisibilityCalculator()
window_cache = runner.precompute_window_cache(calculator)

# 缓存统计信息
stats = runner.get_cache_statistics()
print(f"缓存命中率: {stats['hit_rate']:.2%}")

# 运行实验（自动使用缓存）
results = runner.run_all()
```

### 2.3 时间步长选择

| 粒度 | 步长 | 适用场景 |
|-----|------|---------|
| 粗粒度 | 60s | 快速估算，可能漏窗口 |
| 标准粒度 | 10s | 平衡选择，推荐默认 |
| 细粒度 | 1s | 高精度需求，计算慢 |

---

## 3. 算法执行流程

### 概述

运行调度算法生成任务分配方案。支持8种算法，通过注册表机制实现即插即用。

### 步骤分解

| 步骤 | 操作 | 输入 | 输出 |
|-----|------|------|------|
| 3.1 | 初始化调度器 | 算法名称、超参数 | 调度器实例 |
| 3.2 | 加载可见性窗口 | 窗口缓存（如可用） | 窗口字典 |
| 3.3 | 生成初始解 | 目标列表、卫星列表 | 初始任务分配方案 |
| 3.4 | 迭代优化 | 初始解、约束条件 | 中间解序列 |
| 3.5 | 收敛判断 | 收敛曲线 | 是否继续标志 |
| 3.6 | 提取最终解 | 算法内部状态 | `ScheduleResult` |

### 3.1 支持的算法

| 算法 | 类型 | 核心机制 | 适用场景 |
|-----|------|---------|---------|
| **Greedy** | 启发式 | 优先级排序 + 最佳分配 | 快速求解、基准对比 |
| **EDD** | 启发式 | 最早截止时间优先 | 最小化最大延误 |
| **SPT** | 启发式 | 最短处理时间优先 | 最小化平均流程时间 |
| **GA** | 元启发式 | 遗传进化（选择、交叉、变异） | 复杂约束优化 |
| **SA** | 元启发式 | 模拟退火（温度、邻域、接受准则） | 逃离局部最优 |
| **ACO** | 元启发式 | 蚁群优化（信息素、启发函数） | 组合优化问题 |
| **PSO** | 元启发式 | 粒子群（速度、位置更新） | 连续/离散混合优化 |
| **Tabu** | 元启发式 | 禁忌搜索（禁忌表、邻域） | 避免循环搜索 |

### 3.2 调度器注册表

```python
# 主入口中的调度器注册表
SCHEDULER_REGISTRY = {
    'greedy': GreedyScheduler,
    'ga': GAScheduler,
    'edd': EDDScheduler,
    'spt': SPTScheduler,
    'sa': SAScheduler,
    'aco': ACOScheduler,
    'pso': PSOScheduler,
    'tabu': TabuScheduler,
}

# 注册新算法
def register_scheduler(name: str, scheduler_class):
    from scheduler.base_scheduler import BaseScheduler
    if not issubclass(scheduler_class, BaseScheduler):
        raise TypeError("Scheduler must inherit from BaseScheduler")
    SCHEDULER_REGISTRY[name.lower()] = scheduler_class
```

### 3.3 算法执行入口

```bash
# 命令行运行
python main.py --scenario scenarios/point_group_scenario.json --algorithm ga

# 带配置参数
python main.py \
    --scenario scenarios/point_group_scenario.json \
    --algorithm ga \
    --config '{"population_size": 200, "generations": 300}'

# 生成可视化
python main.py \
    --scenario scenarios/point_group_scenario.json \
    --algorithm ga \
    --visualize \
    --output results/ga_result.png
```

### 3.4 遗传算法详细流程

```
遗传算法执行流程
────────────────────────────────────────

初始化
  │
  ├── 3.3.1 初始化种群（100个体）
  │   └── 随机生成染色体（任务-卫星编码）
  │
  └── 3.3.2 评估适应度
      └── Fitness = w1×DSR + w2×(1-Makespan/Tmax)

迭代（最多200代）
  │
  ├── 3.4.1 选择：锦标赛选择（选择压力）
  │
  ├── 3.4.2 交叉：单点/多点交叉（概率0.8）
  │
  ├── 3.4.3 变异：随机重分配（概率0.2）
  │
  ├── 3.4.4 精英保留：前10%直接进入下一代
  │
  └── 3.4.5 评估新一代适应度

终止判断
  │
  ├── 达到最大代数（200）→ 终止
  ├── 收敛（最优值10代不变）→ 终止
  └── 否则 → 继续迭代
```

---

## 4. 结果验证流程

### 概述

检查调度方案的可行性，分析未调度任务的失败原因。

### 步骤分解

| 步骤 | 操作 | 输入 | 输出 |
|-----|------|------|------|
| 4.1 | 时间冲突检测 | 任务分配方案 | 时间冲突列表 |
| 4.2 | 资源约束验证 | 卫星状态轨迹 | 资源违规列表 |
| 4.3 | 能力匹配验证 | 卫星能力、目标需求 | 能力不匹配列表 |
| 4.4 | 窗口约束验证 | 访问窗口、任务时间 | 窗口违规列表 |
| 4.5 | 分类失败原因 | 未调度任务列表 | 失败原因统计 |
| 4.6 | 生成验证报告 | 各类验证结果 | 验证报告对象 |

### 失败原因分类

| 类别 | 具体原因 | 说明 |
|-----|---------|------|
| 资源不足 | `INSUFFICIENT_POWER` | 功率预算不足 |
| 资源不足 | `INSUFFICIENT_STORAGE` | 存储容量不足 |
| 资源不足 | `THERMAL_LIMIT_EXCEEDED` | 热控限制 |
| 时间冲突 | `SATELLITE_TIME_CONFLICT` | 卫星时间冲突 |
| 时间冲突 | `GROUND_STATION_CONFLICT` | 地面站冲突 |
| 可见性 | `NO_VISIBILITY_WINDOW` | 无可见窗口 |
| 可见性 | `WINDOW_TOO_SHORT` | 窗口时间不足 |
| 能力 | `CAPABILITY_MISMATCH` | 能力不匹配 |

---

## 5. 性能评估流程

### 概述

计算各类性能指标，评估算法表现。

### 步骤分解

| 步骤 | 操作 | 输入 | 输出 |
|-----|------|------|------|
| 5.1 | 计算需求满足率 | 已调度任务数 / 总任务数 | DSR (0-1) |
| 5.2 | 计算完工时间 | 最后一个任务的完成时间 | Makespan (秒) |
| 5.3 | 计算平均重访时间 | 任务观测间隔均值 | Avg Revisit Time |
| 5.4 | 计算卫星利用率 | 成像时间 / 可用时间 | Utilization (0-1) |
| 5.5 | 计算计算时间 | 算法实际运行时间 | Computation Time |
| 5.6 | 计算综合质量 | 加权组合多个指标 | Solution Quality |

### 性能指标说明

| 指标 | 公式 | 说明 |
|-----|------|------|
| **DSR** | Scheduled / Total | 需求满足率（Demand Satisfaction Rate） |
| **Makespan** | max(CompletionTime) | 完工时间 |
| **Avg Revisit** | avg(RevisitInterval) | 平均重访时间 |
| **Utilization** | ImagingTime / AvailableTime | 卫星利用率 |
| **Comp Time** | AlgorithmExecutionTime | 算法计算时间 |
| **Quality** | 0.6×DSR + 0.4×(1-Makespan/Tmax) | 综合解质量 |

### 指标计算代码

```python
from evaluation.metrics import MetricsCalculator, PerformanceMetrics

# 计算所有指标
metrics_calc = MetricsCalculator(mission)
metrics = metrics_calc.calculate_all(schedule_result)

# 访问指标
print(f"需求满足率: {metrics.demand_satisfaction_rate:.2%}")
print(f"完工时间: {metrics.makespan/3600:.2f} 小时")
print(f"求解时间: {metrics.computation_time:.2f} 秒")
print(f"卫星利用率: {metrics.satellite_utilization:.2%}")

# 导出为字典
data = metrics.to_dict()
```

---

## 6. 批量实验流程

### 概述

系统化比较多个算法在多个场景上的表现，确保统计显著性。支持窗口缓存预计算和参数敏感性分析。

### 步骤分解

| 步骤 | 操作 | 输入 | 输出 |
|-----|------|------|------|
| 6.1 | 配置实验计划 | 算法列表、场景列表、重复次数 | `ExperimentConfig` |
| 6.2 | 预计算窗口缓存 | 场景列表、可见性计算器 | `VisibilityWindowCache` |
| 6.3 | 执行单次实验 | 场景、算法、窗口缓存 | `ExperimentResult` |
| 6.4 | 重复实验 | 重复次数N | N次结果列表 |
| 6.5 | 统计分析 | 重复实验结果 | 统计摘要（均值、标准差、置信区间） |
| 6.6 | 生成对比报告 | 所有实验结果 | 对比报告/图表 |

### 6.1 基础批量实验

```python
from experiments.runner import ExperimentRunner, ExperimentConfig
from scheduler.greedy.greedy_scheduler import GreedyScheduler
from scheduler.greedy.edd_scheduler import EDDScheduler
from scheduler.metaheuristic.ga_scheduler import GAScheduler

# 定义要测试的算法
algorithms = {
    'greedy': GreedyScheduler,
    'edd': EDDScheduler,
    'ga': GAScheduler,
}

# 配置实验
config = ExperimentConfig(
    repetitions=10,           # 每个算法运行10次
    random_seed=None,         # 使用不同随机种子
    output_dir='./results'
)

# 创建运行器
runner = ExperimentRunner(mission, algorithms, config)

# 可选：预计算窗口缓存（显著提升性能）
from core.orbit.visibility.orekit_visibility import OrekitVisibilityCalculator
calculator = OrekitVisibilityCalculator()
runner.precompute_window_cache(calculator)

# 运行所有实验
results = runner.run_all()

# 算法对比
comparison = runner.compare_algorithms()
for alg_name, stats in comparison.items():
    print(f"{alg_name}: DSR={stats['mean_demand_satisfaction_rate']:.3f}")

# 导出结果
runner.export_results('results/experiment.json')

# 生成Markdown报告
report = runner.generate_report()
with open('results/report.md', 'w') as f:
    f.write(report)
```

### 6.2 参数敏感性分析

```python
# 对单个算法进行参数敏感性分析
param_ranges = {
    'population_size': [50, 100, 200],
    'crossover_rate': [0.6, 0.8, 0.9],
    'mutation_rate': [0.05, 0.1, 0.2],
}

sensitivity_results = runner.run_sensitivity_analysis(
    algorithm_name='ga',
    param_ranges=param_ranges
)

# 结果分析
for params, result in sensitivity_results:
    print(f"Params: {params}, DSR: {result.metrics['demand_satisfaction_rate']:.3f}")
```

### 6.3 统计分析方法

```
统计指标
├── 集中趋势
│   ├── 均值 (Mean)
│   └── 中位数 (Median)
│
├── 离散程度
│   ├── 标准差 (StdDev)
│   └── 变异系数 (CV = StdDev/Mean)
│
└── 置信区间
    └── 95% CI (Mean ± 1.96 × SEM)
```

---

## 7. Docker容器化流程

### 概述

使用Docker容器化运行场景配置和实验，确保环境一致性和可复现性。

### 7.1 构建镜像

```bash
# 构建Docker镜像
docker build -t mission-scenario:latest .
```

### 7.2 运行场景配置工具

```bash
# 校验场景
docker run --rm -v $(pwd):/app mission-scenario:latest \
    validate scenarios/test.json

# 生成Walker星座
docker run --rm -v $(pwd):/app mission-scenario:latest \
    walker scenarios/base.json --preset delta_24_3_1

# 参数扫描
docker run --rm -v $(pwd):/app mission-scenario:latest \
    sweep --base-scenario scenarios/base.json \
    --param storage --range 500:2000:100
```

### 7.3 使用Docker Compose

```bash
# 启动服务
docker-compose up scenario-tools

# 运行特定命令
docker-compose run --rm scenario-tools validate scenarios/test.json

# 进入交互式shell
docker-compose run --rm scenario-tools bash
```

### 7.4 CI/CD集成

GitHub Actions示例（`.github/workflows/scenario-validation.yml`）：

```yaml
name: Scenario Validation

on:
  push:
    paths:
      - 'scenarios/**'

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Build Docker Image
        run: docker build -t mission-scenario:latest .

      - name: Validate Scenarios
        run: |
          for scenario in scenarios/*.json; do
            echo "Validating $scenario..."
            docker run --rm -v $(pwd):/app mission-scenario:latest \
              validate "/app/$scenario"
          done

      - name: Check Feasibility
        run: |
          docker run --rm -v $(pwd):/app mission-scenario:latest \
            check-feasibility /app/scenarios/production.json
```

---

## 流程依赖关系

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│   1.场景配置     │────→│  2.可见性计算   │────→│  3.算法执行     │
│  (CLI工具套件)   │     │  (预计算窗口)   │     │  (生成调度方案)  │
└─────────────────┘     └─────────────────┘     └────────┬────────┘
                                                         │
                              ┌─────────────────────────┼─────────────────────────┐
                              ↓                         ↓                         ↓
                       ┌─────────────┐           ┌─────────────┐           ┌─────────────┐
                       │ 4.结果验证  │←────────→│ 5.性能评估  │←────────→│ 6.批量实验  │
                       │(检查可行性) │           │(计算指标)   │           │(系统比较)   │
                       └─────────────┘           └─────────────┘           └─────────────┘
                                                                                ↑
                       ┌───────────────────────────────────────────────────────┘
                       ↓
                ┌─────────────┐
                │7.Docker容器化│
                │(CI/CD集成)  │
                └─────────────┘
```

---

## 附录

### A. 项目目录结构

```
missionPlanAlgo/
├── core/                    # 核心层
│   ├── models/             # 实体模型（卫星、目标、地面站、任务）
│   ├── orbit/              # 轨道模块（传播器、可见性计算、窗口缓存）
│   ├── resources/          # 资源管理（卫星池、地面站池）
│   ├── decomposer/         # 目标分解（条带、网格）
│   ├── processing/         # 在轨处理管理
│   ├── network/            # 星间链路网络与路由
│   ├── dynamic_scheduler/  # 事件驱动和滚动时域调度
│   ├── validators/         # 约束验证
│   └── telecommand/        # 指令序列生成
├── payload/                # 载荷模块（光学/SAR成像器、成像模式）
├── scheduler/              # 调度算法
│   ├── greedy/            # 启发式算法（Greedy、EDD、SPT）
│   └── metaheuristic/     # 元启发式算法（GA、SA、ACO、PSO、Tabu）
├── simulator/             # 离散事件仿真引擎
│   ├── state_tracker.py   # 实时状态追踪
│   ├── thermal_model.py   # 热控模型
│   ├── schedule_validator.py  # 方案验证
│   └── eclipse_calculator.py  # 地影计算
├── evaluation/            # 性能指标与结果分析
├── experiments/           # 实验管理与基准测试
│   └── runner.py          # 实验运行器
├── visualization/         # 甘特图、星下点轨迹、覆盖图
├── scenarios/             # JSON场景配置文件
├── data/entity_lib/       # 实体库（卫星模板、目标、地面站）
├── utils/entity/          # 场景配置工具套件
│   ├── cli/               # CLI命令入口
│   ├── library.py         # 实体库管理
│   ├── builder.py         # 场景构建器
│   ├── validator.py       # 场景校验器
│   ├── walker.py          # Walker星座生成
│   └── repository/        # 数据访问层
├── docs/                  # 架构设计文档与实验流程文档
├── tests/                 # 单元测试与集成测试（80%+ 覆盖率）
├── Dockerfile             # Docker镜像构建
└── docker-compose.yml     # Docker Compose配置
```

### B. 运行入口

```bash
# 单次运行
python main.py --scenario scenarios/point_group_scenario.json --algorithm ga

# 场景配置CLI
sat-cli validate scenarios/test.json
sat-cli walker scenarios/test.json --planes 2 --sats-per-plane 3
sat-cli sweep --base-scenario base.json --param storage --range 500:2000:100

# Docker运行
docker-compose run --rm scenario-tools validate scenarios/test.json

# 批量实验（编程式）
python -c "
from experiments.runner import ExperimentRunner, ExperimentConfig
# ... 配置并运行实验
"
```

### C. 快速开始示例

```bash
# 1. 初始化场景
sat-cli init scenarios/test.json --with-metadata

# 2. 生成Walker星座（6颗卫星，2个轨道面）
sat-cli walker scenarios/test.json \
    --template optical_1 \
    --planes 2 \
    --sats-per-plane 3

# 3. 添加目标
sat-cli add-to-scenario scenarios/test.json \
    --entity-type target \
    --from-file data/china_cities.json

# 4. 校验场景
sat-cli validate scenarios/test.json --verbose

# 5. 运行调度算法
python main.py --scenario scenarios/test.json --algorithm ga --visualize

# 6. 批量对比实验（Python脚本）
python -c "
from experiments.runner import ExperimentRunner, ExperimentConfig
from core.models import Mission
from scheduler.greedy.greedy_scheduler import GreedyScheduler
from scheduler.metaheuristic.ga_scheduler import GAScheduler

mission = Mission.load('scenarios/test.json')
algorithms = {'greedy': GreedyScheduler, 'ga': GAScheduler}
config = ExperimentConfig(repetitions=10)
runner = ExperimentRunner(mission, algorithms, config)
results = runner.run_all()
runner.export_results('results/comparison.json')
"
```

---

*文档版本: 2.0*
*最后更新: 2024-02-22*

## 更新日志

### v2.0 (2024-02-22)
- **重写** 场景配置流程，全面采用CLI工具套件
- **新增** Walker星座生成、参数扫描、场景差异比对
- **新增** 窗口缓存机制说明
- **新增** Docker容器化流程（第7节）
- **更新** 批量实验流程，基于`ExperimentRunner`类
- **更新** 项目目录结构，反映实际实现

### v1.0 (2024-02-21)
- 初始版本
- 基础6步实验流程
